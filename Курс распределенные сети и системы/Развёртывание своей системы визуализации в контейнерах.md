Рассматривается решение по визуализации данных с использованием MQTT-протокола в качестве транспорта с оконечного оборудования. Основные программные компоненты: 
- Mosquitto MQTT
- Telegraf
- InfluxDB
- Grafana
- Node-Red 
Для развертывания будет использоваться контейнеризация на [[Виртуализация и виртуальные машины|виртуальной машине]].
## Высокоуровневое описание решения

![[Pasted image 20250330221157.png]]

Имеется конечное оборудование с доступом в интернет. В тоже время через интернет-провайдера домашнего интернета к сети подключен роутер, который предоставляет доступ в интернет всем участникам локальной сети. При помощи [[DHCP]] устройства, в том числе [[Виртуальная машина]] получают адреса для регистрации в локальной сети. [[Виртуальная машина]], используя режим [[Создание виртуальной машины и установка на нее ОС Linux Debian#^fdc854|Bridged]], получает доступ к физическому сетевому адаптеру, установленному в ПК, и может подключаться к роутеру наравне с остальными участниками локальной сети. На роутере существует функция [[Проброс портов|проброс портов]], она позволит обращаться к выбранному клиенту внутри локальной сети по указанному конкретному порту, например к виртуальной машине. Также на роутере реализована технология [[DDNS]], которая позволит в случае с динамическим белым IP-адресом, в автоматическом режиме перепривязывать динамический IP к определенному доменному имени. Но в данном случае функционал DDNS вынесен на виртуальную машину, где будет развернут отдельный [[Контейнеризация и контейнер|контейнер]] с DDNS-утилитой для работы с сервисом [[Создание домена в сервисе DDNS#^2afd71|noip.com]]. Это необходимо, чтобы организовать доступ к сервисам, развернутым на виртуальной машине через интернет. Доступ будет осуществляться через доменное имя, с [[Проксирование (Proxy-сервер)#Reverse Proxy Server (обратный прокси)|обратным прокси]], через [[HTPPS]] подключение.

## Описание взаимодействия ПО

![[Pasted image 20250330222208.png]]
#### [[MQTT]]
Оконечное оборудование в терминах [[MQTT]] выполняет функцию Publisher, т.е. издает данные на MQTT-брокер Mosquitto MQTT, который, в общем, выполняет задачу посредника, помогая системе взаимодействовать с оконечным устройством по протоколу MQTT, и позволяя подписчикам (Subscribers)  считывать данные из для последующей обработки.
#### [[Telegraf]]
Для получения данных с MQTT брокера нам необходимо реализовать функцию Subscribe, т.е. подписаться на определенный топик и считать данные, которые нам отправило оконечное устройство. Задача сервисного агента Telegraf - выполнять чтение данных с брокера и осуществлять их сохранение в базу данных InfluxDB.
#### [[Node-RED]]
Если требуется промежуточная обработка данных, то можно воспользоваться Node-RED, который также подпишется на MQTT брокер, осуществит необходимые преобразования данных, и отправит их в InfluxDB на хранение.
#### [[InfluxDB]]
База данных InfluxDB является хранилищем для данных, полученных через связку: 
	`ОУ -> MQTT -> Telegraf`
Каждой записанной метрике присваивается [[InfluxDB#^92348e|timestamp]] и в таком виде они хранятся в БД.
#### [[Grafana]]
Grafana, подключенная к БД через определенный запрос забирает нужные метрики за заданный интервал времени и визуализирует на настроенном пользователем дашборде.
#### [[Wireguard]]
Wireguard позволит реализовать защищенный доступ на виртуальную машину и получить к ней безопасный доступ через интернет

## Алгоритм развертывания сервисов

[[Алгоритм развертывания сервисов в Docker контейнерах|Выполним развертывание сервисов в Docker контейнерах]].

После развертывания контейнеров и конфигурации базовых компонентов, можно выполнить команду `docker ps` и удостовериться что все контейнеры запущены (имеют статус Up). Далее следует проверить работоспособность компонентов и связать все компоненты в единую систему (единый поток обработки данных).

### Проверка MQTT-Mosquitto

Воспользуемся утилитой [[Mosquitto-clients]], которую мы  [[Алгоритм развертывания сервисов в Docker контейнерах#^4da079|устанавливали]] вместе с контейнерами. Выполним команду `mosquitto_pub`, чтобы опубликовать данные:

```bash
 mosquitto_pub -h 192.168.1.100 -p 1883 -t "Dev-IoT" -m "21.2" -u "IoT" -P "student"
```

В новом окне терминала выполним команду `mosquitto_sub` чтобы выполнить подписку на брокер с тем же портом в тот же топик, который мы опубликовали, и реквизитами для подключения:

```bash
mosquitto_sub -h 192.168.1.100 -p 1883 -t "Dev-IoT" -u "IoT" -P "student"
```

Факт того, что подписчик получает данные, которые мы публикуем, подтверждает работоспособность [[MQTT|Mosquitto-брокера]]. 

### Проверка  [[Telegraf]] + [[InfluxDB]]

Далее для проверки связки [[Telegraf]] + [[InfluxDB]] необходимо в браузере ввести адрес своей виртуальной машины и указать порт InfluxDB (`192.168.1.100:8086`) водим логин и пароль, который указывали в процессе конфигурации.
	*Если потеряли токен, который был сгенерирован при конфигурации, то новый можно сгенерировать в разделе* `Load Data -> API Tokens`.
Теперь нужно проверить, что Telegraf записал данные в InfluxDB, которые мы публиковали командой `mosquitto_pub`. Для этого:

* Переходим на вкладку `Data Explorer`
* Выбираем [[InfluxDB#^ec7b87|бакет]] `IoT`
* Фильтр `_measurment`, [[InfluxDB#^92348e|тэг]] - `mqtt_cunsumer` (это само по себе является подтверждением работоспособности связки с Telegraf, т.к. это именно он создает этот тэг в процессе работы с MQTT-брокером)
* [[MQTT#^3d7213|Топик]] - Dev-IoT, хост - `############` 
* Aggregate function - `last` - чтобы данные выводились в практически неизмененном виде
* Жмем `SUBMIT` и наблюдаем график значений, которые мы раннее передали на MQTT брокер.

Чтобы посмотреть запрос, который отправляется в базу данных, можно перейти на вкладку `SCRIPT EDITOR` и увидеть код запроса, который реально отправляется в БД:

```json
from(bucket: "IoT")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r["_measurement"] == "mqtt_consumer")
  |> filter(fn: (r) => r["_field"] == "value")
  |> filter(fn: (r) => r["topic"] == "Dev-IoT")
  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)
  |> yield(name: "last")
```

^0578ed

Этот скрипт мы будем использовать для построения дашбордов в Grafana.

### Проверка и настройка Grafana

Далее проверим работоспособность [[Grafana]], соединим ее с InfluxDB и создадим дашборд. 

В новой вкладке браузера вводим адрес своей виртуальной машины и порт (который мы указали раннее в файле конфигурации Docker Compose) Grafana (`192.168.1.100:3000`) . Вводим логин `admin` и пароль `mxA373&o`.

##### Подключение к [[InfluxDB]]
Далее необходимо настроить подключение к [[InfluxDB]]:

* Открываем основное меню. Вкладка `Connections`->`Add new connections`
* В строке поиска вводим InfluxDB, выбираем подходящий результат поиска, жмем кнопку `Add new data source`. Теперь необходимо сконфигурировать этот источник данных:
	* Query language - `flux`
	* URL(точка подключения для InfluxDB(можно скопировать из соседней вкладки браузера)) - `http://192.168.1.100:8086`
	* InfluxDB Deatils
		* Organization - IoT (указывался в файле конфигурации `settings.sh`)
		* Token - вставляем раннее сгенерированный токен
		* Default bucket - IoT 
* Если все удачно, то появится зеленая плашка, что установлена связь с источником данных.

##### Создадим дашборд: 
основное меню -> вкладка `Dashboards` -> New -> New dashboard -> Save dashboard (вводим желаемое название и т.д.) -> Save

##### Добавим визуализацию:
Add visualization -> Select data source (InfluxDB) -> Попадаем в конструктор, который состоит из:
* Сверху - выборка данных (собственно визуализация данных)
* Справа - настройка панели выборки (при внесении изменений, при нажатии на кнопку сохранения дашборда, можно посмотреть код изменений, которые мы выполнили на вкладке `changes`) 
* Снизу - запрос в базу данных (туда нужно скопировать тот самый [[Развёртывание своей системы визуализации в контейнерах#^0578ed|скрипт]], который был сгенерирован в InfluxDB)

### Проверка работы [[Node-RED]] и обзор возможностей

В новой вкладке браузера вводим адрес своей виртуальной машины и порт (который мы указали раннее в файле конфигурации Docker Compose) Grafana (`192.168.1.100:1880 `) . Вводим логин `admin` и пароль `mxA373&o`.

[[Описание основных элементов интерфейса Node-RED]]

Реализуем механизм эмуляции оконечного оборудования: 
* Установим дополнительные ноды:
	* ≡ -> управление палитрой -> вкладка установить -> вводим `node-red-contrib-influxdb` -> установить
	*  аналогично устанавливаем `random-generator_node-red-contrib`
* переносим на холст метку времени (`inject`) и связываем ее с нодой создание случайного  значения (`Random number`). В результате получим генерацию случайного значения в определенный момент времени. В параметрах ноды укажем диапазон случайных чисел и число знаков после запятой
* чтобы видеть сгенерированное значение добавим ноду `debug`
*  чтобы отправить данные далее по [[MQTT]] добавим соответствующую ноду (`mqtt out`). Далее необходимо настроить подключение к брокеру. 
	* В настройках ноды в поле `Сервер` указываем адрес нашей виртуальной машины и порт Node-RED `192.168.1.100:1883`;
	* Protocol - MQTT V5
	* Вкладка безопасность - имя пользователя и пароль для MQTT-брокера (IoT / student)
	* Тема - `/test/temp`, в этот топик мы будем отправлять данные
	* [[QoS]] - 1

Реализуем функционал, для которого раннее мы использовали Telegraf:
* Добавим ноду `mqtt in`, которая будет принимать данные от брокера MQTT и передавать данные в [[InfluxDB]] . Далее необходимо настроить ноду на получение данных с брокера.
	* Настройки соединения - аналогично 
	* Логин, пароль - аналогично
	* Atction - `Subscribe to single topic`
	* Тема указываем тот же топик, куда мы публикуем сообщения - `/test/temp`
*  Добавим и настроим ноду  `influxdb in`:
	* Version - `2.0`;
	* URL - указываем адрес нашей виртуальной машины и порт InfluxDB `192.168.1.100:8086`;
	* Token - указываем сгенерированный раннее токен
	* Organization - `IoT`
	* Bucket - `IoT` 
	* Measurement - `Test Temp` 
Также можно подключить ноды `debug`, чтобы отслеживать передаваемое значение

### Проверка работы Wireguard

В Termius по [[SFTP]] подключимся к нашей виртуальной машине, чтобы в более привычном виде наблюдать файловую систему.

Нас интересует каталог `wireguard` -> `config` -> каталоги `peer1` - `peer10`. В каждом из них лежит QR-код и файл конфигурации. Из любой папки копируем на основную машину файл `peer[#].conf` либо QR-код.

Далее устанавливаем на любое другое устройство нашей локальной сети клиент Wireguard и забираем любым удобным файл `peer[#].conf` либо QR-код. Загружаем файл настроек в клиент. Чтобы иметь доступ к VPN-серверу через интернет и подключаться с помощью других устройств (например смартфона) нужно осуществить проброс порта `51820` для UDP через настройки роутера на свою виртуальную машину. Также нужно изменить в настройках созданного подключения в WireGuard адрес ВМ в локальной сети `192.168.1.100` на [[Белые и серые IP-адреса|белый]] IP-адрес роутера `85.21.144.63` в сети провайдера. 

Если все удачно то в клиенте можно наблюдать изменение количества трафика.

### [[Проброс портов]] , для доступа к сервисам через интернет

![[Pasted image 20250413141856.png]]

### Завершение создание распределенной системы

После [[Развёртывание своей системы визуализации в контейнерах#Алгоритм развертывания сервисов|проверки работоспособности]] развернутых компонентов, следует завершить создание распределенной системы с доступом через интернет, дополнительно развернув сервисы [[NGINX]], [[Certbot]] и [[Inadyn]] по [[Продолжение алгоритма развертывания сервисов в Docker контейнерах|этой]] инструкции.










